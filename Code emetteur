import pandas as pd

def controle_coherence_tiers_emetteur(df_titres, df_dimension, df_transco):
    """
    Pour chaque code titre:
      - récupérer l'Issuer (format Dimension) via DIMENSION,
      - accepter OK si TIERS_EMETTEUR (format Titres) est dans l'une des transcos possibles de cet Issuer.
    Retour: Series 'Résultat' (OK/KO) alignée sur l'index d'entrée de df_titres.
    """
    # Noms de colonnes (identiques à tes captures)
    col_code_titre   = 'ID_TITRE2'
    col_tiers_titres = 'TIERS_EMETTEUR'
    col_sec_id       = 'Security ID CODA'
    col_issuer       = 'Issuer'
    col_transco1     = 'Transco 1'   # format Dimension
    col_code2        = 'Code 2'      # format Titres

    # 0) préserver l'index d'entrée
    base = df_titres.copy()
    base['__orig_idx__'] = base.index

    # 1) TITRES × DIMENSION sur le code titre (many-to-one)
    dim_unique = df_dimension[[col_sec_id, col_issuer]].drop_duplicates(subset=[col_sec_id])
    dfm = base.merge(
        dim_unique,
        how='left',
        left_on=col_code_titre,
        right_on=col_sec_id,
    )

    # 2) Dictionnaire: {Issuer (dimension) -> set de transcos (codes Titres) possibles}
    transco_map = (
        df_transco[[col_transco1, col_code2]]
        .astype({col_transco1: str, col_code2: str})
        .groupby(col_transco1)[col_code2]
        .apply(lambda s: set(s.dropna().unique()))
        .to_dict()
    )

    # 3) Comparaison: OK si TIERS_EMETTEUR ∈ transcos possibles(Issuer)
    tiers_vals  = dfm[col_tiers_titres].astype(str).tolist()
    issuer_keys = dfm[col_issuer].astype(str).tolist()

    res = []
    for t, k in zip(tiers_vals, issuer_keys):
        possibles = transco_map.get(k, set())  # set() si aucun mapping
        res.append('OK' if t in possibles else 'KO')

    # 4) Sortie: Series alignée sur l'index d'origine (même format que tes autres règles)
    out = pd.Series(res, index=dfm['__orig_idx__'], name='Résultat')
    out.index.name = None
    return out'

# Série résultat initialisée (même que d’habitude)
results_coherence_emetteur = pd.Series(['NA'] * len(df_Titres), index=df_Titres.index)

# Sous-ensemble à contrôler (garde ta logique de filtrage habituelle)
df_coherent_emetteur = df_Titres.loc(
    (results_completude["TIERS_EMETTEUR"] == "OK") & 
    (results_coherence_id_titre == "OK"),
    ["ID_TITRE2", "TIERS_EMETTEUR"]
)

# Appel de la fonction
results_coherence_emetteur_ok = controle_coherence_tiers_emetteur(
    df_coherent_emetteur, df_Dimension, df_Transco_tiers
)

# Affectation au format identique aux autres règles (sans Length mismatch)
results_coherence_emetteur.loc[df_coherent_emetteur.index] = (
    results_coherence_emetteur_ok.reindex(df_coherent_emetteur.index).values
)



# (Optionnel) audit complet
audit = df_coherent_emetteur.copy()
dim_unique = df_Dimension[['Security ID CODA','Issuer']].drop_duplicates(subset=['Security ID CODA'])
audit = audit.merge(dim_unique, how='left', left_on='ID_TITRE2', right_on='Security ID CODA')
audit['Transcos possibles'] = audit['Issuer'].astype(str).map(
    lambda k: ','.join(sorted(transco_map.get(k, set())))  # nécessite transco_map dans le scope
)
audit['Résultat'] = results_coherence_emetteur_ok.reindex(audit.index).values
# audit.to_excel('df_jointure_emetteur.xlsx', index=False)
 
